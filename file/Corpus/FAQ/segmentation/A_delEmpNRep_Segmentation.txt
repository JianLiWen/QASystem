Java 虚拟机 是 一个 可以 执行 Java 字节 码 的 虚拟机 进程 。 Java 源文件 被 编译 成 能 被 Java 虚拟机 执行 的 字节 码 文件 。 Java 被 设计 成 允许 应用 程序 可以 运行 在 任意 的 平台 ， 而 不 需要 程序员 为 每 一个 平台 单独 重写 或者 是 重新 编译 。 Java 虚拟机 让 这个 变为 可能 ， 因为 它 知道 底层 硬件 平台 的 指令 长度 和 其他 特性 。 
ArrayList 和 LinkedList 都 实现 了 List 接口 ， 他们 有 以下 的 不同 点 ： ArrayList 是 基于 索引 的 数据 接口 ， 它 的 底层 是 数组 。 它 可以 以 O ( 1 ) 时间 复杂 度 对 元素 进行 随机 访问 。 与 此 对应 ， LinkedList 是 以 元素 列表 的 形式 存储 它 的 数据 ， 每 一个 元素 都 和 它 的 前 一个 和 后 一个 元素 链 接 在 一起 ， 在 这种 情况 下 ， 查找 某个 元素 的 时间 复杂 度 是 O ( n ) 。 相对 于 ArrayList ， LinkedList 的 插入 ， 添加 ， 删除 操作 速度 更 快 ， 因为 当 元素 被 添加 到 集合 任意 位置 的 时候 ， 不 需要 像 数组 那样 重新 计算 大小 或者 是 更新 索引 。 LinkedList 比 ArrayList 更 占 内存 ， 因为 LinkedList 为 每 一个 节点 存储 了 两 个 引用 ， 一个 指向 前 一个 元素 ， 一个 指向 下 一个 元素 。 也 可以 参考 ArrayList   vs.   LinkedList 。 
克隆 ( cloning ) 或者 是 序列 化 ( serialization ) 的 语义 和 含义 是 跟 具体 的 实现 相关 的 。 因此 ， 应该 由 集合 类 的 具体 实现 来 决定 如何 被 克隆 或者 是 序列 化 。 
Java 中 的 HashMap 使用 hashCode ( ) 和 equals ( ) 方法 来 确定 键 值 对 的 索引 ， 当 根据 键 获取 值 的 时候 也 会 用 到 这 两 个 方法 。 如果 没有 正确 的 实现 这 两 个 方法 ， 两 个 不同 的 键 可能 会 有 相同 的 hash 值 ， 因此 ， 可能 会 被 集合 认为 是 相等 的 。 而且 ， 这 两 个 方法 也 用 来 发现 重复 元素 。 所以 这 两 个 方法 的 实现 对 HashMap 的 精确性 和 正确性 是 至关重要 的 。 
下面 列出 了 Array 和 ArrayList 的 不同 点 ： Array 可以 包含 基本 类型 和 对象 类型 ， ArrayList 只能 包含 对象 类型 。 Array 大小 是 固定 的 ， ArrayList 的 大小 是 动态 变化 的 。 ArrayList 提供 了 更 多 的 方法 和 特性 ， 比如 ： addAll ( ) ， removeAll ( ) ， iterator ( ) 等等 。 对于 基本 类型 数据 ， 集合 使用 自动 装箱 来 减少 编码 工作量 。 但是 ， 当 处理 固定 大小 的 基本 数据 类型 的 时候 ， 这种 方式 相对 比较 慢 。 
HashMap 和 Hashtable 都 实现 了 Map 接口 ， 因此 很 多 特性 非常 相似 。 但是 ， 他们 有 以下 不同 点 ： HashMap 允许 键 和 值 是 null ， 而 Hashtable 不 允许 键 或者 值 是 null 。 Hashtable 是 同步 的 ， 而 HashMap 不 是 。 因此 ， HashMap 更 适合 于 单线 程 环境 ， 而 Hashtable 适合 于 多 线程 环境 。 HashMap 提供 了 可 供 应用 迭 代 的 键 的 集合 ， 因此 ， HashMap 是 快速 失败 的 。 另一方面 ， Hashtable 提供 了 对 键 的 列举 ( Enumeration ) 。 一般 认为 Hashtable 是 一个 遗留 的 类 。 
Java 中 的 HashMap 是 以 键 值 对 ( key - value ) 的 形式 存储 元素 的 。 HashMap 需要 一个 hash 函数 ， 它 使用 hashCode ( ) 和 equals ( ) 方法 来 向 集合 / 从 集合 添加 和 检索 元素 。 当 调用 put ( ) 方法 的 时候 ， HashMap 会 计算 key 的 hash 值 ， 然后 把 键 值 对 存储 在 集合 中 合适 的 索引 上 。 如果 key 已经 存在 了 ， value 会 被 更新 成 新 值 。 HashMap 的 一些 重要 的 特性 是 它 的 容量 ( capacity ) ， 负载 因子 ( loadfactor ) 和 扩容 极限 ( threshold   resizing ) 。 
集合 类 接口 指定 了 一 组 叫做 元素 的 对象 。 集合 类 接口 的 每 一 种 具体 的 实现 类 都 可以 选择 以 它 自己 的 方式 对 元素 进行 保存 和 排序 。 有 的 集合 类 允许 重复 的 键 ， 有些 不 允许 。 Java 集合 类 提供 了 一 套 设计 良好 的 支持 对 一 组 对象 进行 操作 的 接口 和 类 。 Java 集合 类 里面 最 基本 的 接口 有 ： Collection ： 代表 一 组 对象 ， 每 一个 对象 都 是 它 的 子 元素 。 Set ： 不 包含 重复 元素 的 Collection 。 List ： 有 顺序 的 collection ， 并且 可以 包含 重复 元素 。 Map ： 可以 把 键 ( key ) 映射 到 值 ( value ) 的 对象 ， 键 不 能 重复 。 
Iterator 接口 提供 了 很多 对 集合 元素 进行 迭 代 的 方法 。 每 一个 集合 类 都 包含 了 可以 返回 迭 代 器 实例 的 
下面 列出 了 他们 的 区别 ： Iterator 可 用 来 遍 历 Set 和 List 集合 ， 但是 ListIterator 只能 用 来 遍 历 List 。 Iterator 对 集合 只能 是 前 向 遍 历 ， ListIterator 既 可以 前 向 也 可以 后 向 。 ListIterator 实现 了 Iterator 接口 ， 并 包含 其他 的 功能 ， 比如 ： 增加 元素 ， 替换 元素 ， 获取 前 一个 和 后 一个 元素 的 索引 ， 等等 。 
使用 多 线程 的 时候 ， 一 种 非常 简单 的 避免 死锁 的 方式 就 是 ： 指定 获取 锁 的 顺序 ， 并 强制 线程 按照 指定 的 顺序 获取 锁 。 因此 ， 如果 所有 的 线程 都 是 以 同样 的 顺序 加 锁 和 释放 锁 ， 就 不 会 出现 死锁 了 。 
监视器 和 锁 在 Java 虚拟机 中 是 一 块 使用 的 。 监视器 监视 一 块 同步 代码 块 ， 确保 一 次 只 有 一个 线程 执行 同步 代码 块 。 每 一个 监视器 都 和 一个 对象 引用 相 关联 。 线程 在 获取 锁 之前 不 允许 执行 同步 代码 。 
有 4 种 方式 可以 用来 创建 线程 ： 继承 Thread 类 实现 Runnable 接口 应用 程序 可以 使用 Executor 框架 来 创建 线程 池 
继承 给 对象 提供 了 从 基 类 获取 字段 和 方法 的 能力 。 继承 提供 了 代码 的 重用 性 ， 也 可以 在 不 修改 类 的 情况 下 给 现存 的 类 添加 新 特性 。 
多 态 是 编程 语言 给 不同 的 底层 数据 类型 做 相同 的 接口 展示 的 一 种 能力 。 一个 多 态 类型 上 的 操作 可以 应用 到 其他 类型 的 值 上面 。 
封装 给 对象 提供 了 隐藏 内部 特性 和 行为 的 能力 。 对象 提供 一些 能 被 其他 对象 访问 的 方法 来 改变 它 内部 的 数据 。 在 Java 当中 ， 有 3 种 修饰符 ： public ， private 和 protected 。 每 一 种 修饰符 给 其他 的 位于 同一个 包 或者 不 同 包 下面 对象 赋予 了 不同 的 访问 权限 。 下面 列出 了 使用 封装 的 一些 好处 ： 通过 隐藏 对象 的 属性 来 保护 对象 内部 的 状态 。 提高 了 代码 的 可用性 和 可 维护 性 ， 因为 对象 的 行为 可以 被 单独 的 改变 或者 是 扩展 。 禁止 对象 之间 的 不良 交互 提高 模块 化 。 
代码 开发 模块 化 ， 更 易 维护 和 修改 。 代码 复用 。 增强 代码 的 可靠性 和 灵活性 。 增加 代码 的 可 理解 性 。 面向 对象 编程 有 很多 重要 的 特性 ， 比如 ： 封装 ， 继承 ， 多 态 和 抽象 。 
JSP 隐含 对象 是 页面 中 的 一些 Java 对象 ， JSP 容器 让 这些 Java 对象 可以 为 开发 者 所 使用 。 开发 者 不 用 明确 的 声明 就 可以 直接 使用 他们 。 JSP 隐含 对象 也 叫做 预定 义 变量 。 下面 列出 了 JSP 页面 中 的 隐含 对象 ： applicationpagerequestresponsesessionexceptionoutconfigpageContext 
【 列表 很 长 ， 可以 分 上 、 中 、 下 发布 】 JSP 表达式 是 Web 服务器 把 脚本 语言 表达 式 的 值 转化 成 一个 String 对象 ， 插入 到 返回 给 客户端 的 数据流 中 。 表达式 是 在 这 两 个 标签 之间 定义 的 。 
声明 跟 Java 中 的 变量 声明 很 相似 ， 它 用 来 声明 随后 要 被 表达式 或者 scriptlet 使用 的 变量 。 添加 的 声明 必须 要 用 开始 和 结束 标签 包 起来 。 
JSP 技术 中 ， scriptlet 是 嵌入 在 JSP 页面 中 的 一 段 Java 代码 。 scriptlet 是 位于 标签 内部 的 所有 的 东西 ， 在 标签 与 标签 之间 ， 用户 可以 添加 任意 有效 的 scriplet 。 
JSP 动作 以 XML 语法 的 结构 来 控制 Servlet 引擎 的 行为 。 当 JSP 页面 被 请求 的 时候 ， JSP 动作 会 被 执行 。 它们 可以 被 动态 的 插入 到 文件 中 ， 重 用 JavaBean 组 件 ， 转发 用户 到 其他 的 页面 ， 或者 是 给 Java 插 件 产生 HTML 代码 。 下面 列出 了 可用 的 动作 ： jsp:include - 当 JSP 页面 被 请求 的 时候 包含 一个 文件 。 jsp:useBean - 找 出 或者 是 初始化 Javabean 。 jsp:setProperty - 设置 JavaBean 的 属性 。 jsp:getProperty - 获取 JavaBean 的 属性 。 jsp:forward - 把 请求 转发 到 新 的 页面 。 jsp:plugin - 产生 特定 浏览器 的 代码 。 
Directive 是 当 JSP 页面 被 编译 成 Servlet 的 时候 ， JSP 引擎 要 处理 的 指令 。 Directive 用 来 设置 页面 级别 的 指令 ， 从 外部 文件 插入 数据 ， 指定 自 定义 的 标签 库 。 Directive 是 定义 在   之间 的 。 下面 列出 了 不同 类型 的 Directive ： 包含 指令 ( Include   directive ) ： 用 来 包含 文件 和 合并 文件 内容 到 当前 的 页面 。 页面 指令 ( Page   directive ) ： 用 来 定义 JSP 页面 中 特定 的 属性 ， 比如 错误 页面 和 缓冲区 。 Taglib 指令 ：   用 来 声明 页面 中 使用 的 自 定义 的 标签 库 。 
下面 列出 了 使用 JSP 的 优点 ： JSP 页面 是 被 动态 编译 成 Servlet 的 ， 因此 ， 开发 者 可以 很 容易 的 更新 展现 代码 。 JSP 页面 可以 被 预 编译 。 JSP 页面 可以 很 容易 的 和 静态 模板 结合 ， 包括 ： HTML 或者 XML ， 也 可以 很 容易 的 和 产生 动态 内容 的 代码 结合 起来 。 开发 者 可以 提供 让 页面 设计者 以 类 XML 格式 来 访问 的 自 定义 的 JSP 标签 库 。 开发 者 可以 在 组件 层 做 逻辑 上 的 改变 ， 而 不 需要 编辑 单独 使用 了 应用 层 逻辑 的 页面 。 
浏览器 首先 要 请求 一个 以 . jsp 扩展名 结尾 的 页面 ， 发起 JSP 请求 ， 然后 ， Web 服务器 读取 这个 请求 ， 使用 JSP 编译器 把 JSP 页面 转化 成 一个 Servlet 类 。 需要 注意 的 是 ， 只有 当 第一 次 请求 页面 或者 是 JSP 文件 发生 改变 的 时候 JSP 文件 才 会 被 编译 ， 然后 服务器 调用 servlet 类 ， 处理 浏览器 的 请求 。 一旦 请求 执行 结束 ， servlet 会 把 响应 发 送给 客户端 。 这里 看 下 如何 在 JSP 中 获取 请求 参数 。 
JSP 页面 是 一 种 包含 了 静态 数据 和 JSP 元素 两 种 类型 的 文本 的 文本 文档 。 静态 数据 可以 用 任何 基于 文本 的 格式 来 表示 ， 比如 ： HTML 或者 XML 。 JSP 是 一 种 混合 了 静态 内容 和 动态 产生 的 内容 的 技术 。 这里 看 下 JSP 的 例子 。 
URL 编码 是 负责 把 URL 里面 的 空格 和 其他 的 特殊 字符 替换 成 对应 的 十六进制 表示 ， 反之 就 是 解码 。 
sendRedirect ( ) 方法 会 创建 一个 新 的 请求 ， 而 forward ( ) 方法 只是 把 请求 转发 到 一个 新 的 目标 上 。 重 定向 ( redirect ) 以后 ， 之前 请求 作用 域 范围 以内 的 对象 就 失效 了 ， 因为 会 产生 一个 新 的 请求 ， 而 转发 ( forwarding ) 以后 ， 之前 请求 作用 域 范围 以内 的 对象 还是 能 访问 的 。 一般 认为 sendRedirect ( ) 比 forward ( ) 要 慢 。 
HTTP 隧道 是 一 种 利用 HTTP 或者 是 HTTPS 把 多种 网络 协议 封装 起来 进行 通信 的 技术 。 因此 ， HTTP 协议 扮演 了 一个 打通 用于 通信 的 网络 协议 的 管道 的 包装 器 的 角色 。 把 其他 协议 的 请求 掩盖 成 HTTP 的 请求 就 是 HTTP 隧道 。 
浏览器 和 Servlet 通信 使用 的 是 HTTP 协议 。 
cookie 是 Web 服务器 发送 给 浏览器 的 一 块 信息 。 浏览器 会 在 本地 文件 中 给 每 一个 Web 服务器 存储 cookie 。 以后 浏览器 在 给 特定 的 Web 服务器 发 请求 的 时候 ， 同时 会 发送 所有 为 该 服务器 存储 的 cookie 。 下面 列出 了 session 和 cookie 的 区别 ： 无论 客户端 浏览器 做 怎么样 的 设置 ， session 都 应该 能 正常 工作 。 客户端 可以 选择 禁用 cookie ， 但是 ， session 仍然 是 能够 工作 的 ， 因为 客户端 无法 禁用 服务端 的 session 。 在 存储 的 数据 量 方面 session 和 cookies 也 是 不 一样 的 。 session 能够 存储 任意 的 Java 对象 ， cookie 只能 存储 String 类型 的 对象 。 
HTTP 响应 由 三 个 部分 组成 ： 状态 码 ( Status   Code ) ： 描述 了 响应 的 状态 。 可以 用 来 检查 是否 成功 的 完成 了 请求 。 请求 失败 的 情况 下 ， 状态 码 可 用 来 找 出 失败 的 原因 。 如果 Servlet 没有 返回 状态 码 ， 默认 会 返回 成功 的 状态 码 HttpServletResponse.SC_OK 。 HTTP 头部 ( HTTP   Header ) ： 它们 包含 了 更 多 关于 响应 的 信息 。 比如 ： 头部 可以 指定 认为 响应 过期 的 过期 日期 ， 或者 是 指定 用 来 给 用户 安全 的 传输 实体 内容 的 编码 格式 。 如何 在 Serlet 中 检索 HTTP 的 头部 看 这里 。 主体 ( Body ) ： 它 包含 了 响应 的 内容 。 它 可以 包含 HTML 代码 ， 图片 ， 等等 。 主体 是 由 传输 在 HTTP 消息 中 紧跟 在 头部 后面 的 数据 字节 组成 的 。 
ServletRequest 类 可以 找 出 客户端 机器 的 IP 地址 或者 是 主机 名 。 getRemoteAddr ( ) 方法 获取 客户端 主机 的 IP 地址 ， getRemoteHost ( ) 可 以 获取 主机 名 。 
Servlet 链 是 把 一个 Servlet 的 输出 发送 给 另 一个 Servlet 的 方法 。 第二 个 Servlet 的 输出 可以 发 送给 第三 个 Servlet ， 依次 类推 。 链条 上 最后 一个 Servlet 负责 把 响应 发 送给 客户端 。 
服务端 包含 ( SSI ) 是 一 种 简单 的 解释 型 服务端 脚本 语言 ， 大多数 时候 仅 用 在 Web 上 ， 用 servlet 标签 嵌入 进来 。 SSI 最 常用 的 场景 把 一个 或 多 个 文件 包含 到 Web 服务器 的 一个 Web 页面 中 。 当 浏览器 访问 Web 页面 的 时候 ， Web 服务器 会 用 对应 的 servlet 产生 的 文本 来 替换 Web 页面 中 的 servlet 标签 。 
Web 应用 程序 是 对 Web 或者 是 应用 服务器 的 动态 扩展 。 有 两 种 类型 的 Web 应用 ： 面向 表现 的 和 面向 服务 的 。 面向 表现 的 Web 应用 程序 会 产生 包含 了 很 多 种 标记 语言 和 动态 内容 的 交互 的 web 页面 作为 对 请求 的 响应 。 而 面向 服务 的 Web 应用 实现 了 Web 服务 的 端点 ( endpoint ) 。 一般来说 ， 一个 Web 应用 可以 看成 是 一 组 安装 在 服务器 URL 名称 空间 的 特定 子集 下面 的 Servlet 的 集合 。 
doGet ： GET 方法 会 把 名 值 对 追加 在 请求 的 URL 后面 。 因为 URL 对 字符 数目 有 限制 ， 进而 限制 了 用 在 客户端 请求 的 参 数值 的 数目 。 并且 请求 中 的 参数 值 是 可 见 的 ， 因此 ， 敏感 信息 不 能 用 这种 方式 传递 。 doPOST ： POST 方法 通过 把 请求 参数 值 放在 请求 体 中 来 克服 GET 方法 的 限制 ， 因此 ， 可以 发送 的 参数 的 数目 是 没有 限制 的 。 最后 ， 通过 POST 请求 传递 的 敏感 信息 对 外部 客户端 是 不 可 见 的 。 
对 每 一个 客户端 的 请求 ， Servlet 引擎 载入 Servlet ， 调 用 它 的 init ( ) 方法 ， 完成 Servlet 的 初始化 。 然后 ， Servlet 对象 通过 为 每 一个 请求 单独 调用 service ( ) 方法 来 处理 所有 随后 来自 客户端 的 请求 ， 最后 ， 调用 Servlet ( 译者 注 ： 这里 应该 是 Servlet 而 不 是 server ) 的 destroy ( ) 方法 把 Servlet 删除 掉 。 
Applet 是 运行 在 客户端 主机 的 浏览器 上 的 客户端 Java 程序 。 而 Servlet 是 运行 在 web 服务器 上 的 服务端 的 组件 。 applet 可以 使用 用户 界面 类 ， 而 Servlet 没有 用户 界面 ， 相反 ， Servlet 是 等待 客户端 的 HTTP 请求 ， 然后 为 请求 产生 响应 。 
所有 的 Servlet 都 必须 要 实现 的 核心 的 接口 是 javax.servlet.Servlet 。 每 一个 Servlet 都 必须 要 直接 或者 是 间接 实现 这个 接口 ， 或者 是 继承 javax.servlet.GenericServlet 或者 javax.servlet.http.HTTPServlet 。 最后 ， Servlet 使用 多 线程 可以 并 行 的 为 多 个 请求 服务 。 
Servlet 是 用 来 处理 客户端 请求 并 产生 动态 网页 内容 的 Java 类 。 Servlet 主要 是 用 来 处理 或者 是 存储 HTML 表 单 提交 的 数据 ， 产生 动态 内容 ， 在 无 状态 的 HTTP 协议 下 管理 状态 信息 。 
Java 提供 了 一 种 叫做 对象 序列 化 的 机制 ， 他 把 对象 表示 成 一连串 的 字节 ， 里面 包含 了 对象 的 数据 ， 对象 的 类型 信息 ， 对象 内部 的 数据 的 类型 信息 等等 。 因此 ， 序列 化 可以 看成 是 为了 把 对象 存储 在 磁盘 上 或者 是 从 磁盘 上 读 出来 并 重建 对象 而 把 对象 扁平 化 的 一 种 方式 。 反 序列 化 是 把 对象 从 扁平 状态 转化 成 活动 对象 的 相反 的 步骤 。 Servlet 
当 应用 程序 希望 把 内存 对象 跨 网络 传递 到 另 一 台 主机 或者 是 持久 化 到 存储 的 时候 ， 就 必须 要 把 对象 在 内存 里面 的 表示 转化 成 合适 的 格式 。 这个 过程 就 叫做 Marshalling ， 反之 就 是 demarshalling 。 
RMISecurityManager 使用 下载 好 的 代码 提供 可 被 RMI 应用 程序 使用 的 安全 管理 器 。 如果 没有 设置 安全 管理 器 ， RMI 的 类 加 载 器 就 不 会 从 远程 下载 任何 的 类 。 
DGC 叫做 分布式 垃圾 回收 。 RMI 使用 DGC 来 做 自动 垃圾 回收 。 因为 RMI 包含 了 跨 虚拟机 的 远程 对象 的 引用 ， 垃圾 回收 是 很 困难 的 。 DGC 使用 引用 计数 算法 来 给 远程 对象 提供 自动 内存 管理 。 
远程 对象 的 stub 扮演 了 远程 对象 的 代表 或者 代理 的 角色 。 调用 者 在 本地 stub 上 调用 方法 ， 它 负责 在 远程 对象 上 执行 方法 。 当 stub 的 方法 被 调 用 的 时候 ， 会 经历 以下 几 个 步骤 ： 初始化 到 包含 了 远程 对象 的 JVM 的 连接 。 序列 化 参数 到 远程 的 JVM 。 等待 方法 调用 和 执行 的 结果 。 反 序列 化 返回 的 值 或者 是 方法 没有 执行 成功 情况 下 的 异常 。 把 值 返回 给 调用 者 。 
为了 让 RMI 程序 能 正确 运行 必须 要 包含 以下 几 个 步骤 ： 编译 所有 的 源文件 。 使用 rmic 生成 stub 。 启动 rmiregistry 。 启动 RMI 服务器 。 运行 客户端 程序 。 
bind ( ) 方法 负责 把 指定 名称 绑定 给 远程 对象 ， rebind ( ) 方法 负责 把 指定 名称 重新 绑定 到 一个 新 的 远程 对象 。 如果 那个 名称 已经 绑定 过 了 ， 先前 的 绑定 会 被 替换 掉 。 
绑定 是 为了 查询 找 远程 对象 而 给 远程 对象 关联 或者 是 注册 以后 会 用 到 的 名称 的 过程 。 远程 对象 可以 使用 Naming 类 的 bind ( ) 或者 rebind ( ) 方法 跟 名称 相 关联 。 
远程 接口 用来 标识 哪些 方法 是 可以 被 非 本地 虚拟机 调用 的 接口 。 远程 对象 必须 要 直接 或者 是 间接 实现 远程 接口 。 实现 了 远程 接口 的 类 应该 声明 被 实现 的 远程 接口 ， 给 每 一个 远程 对象 定义 构造 函数 ， 给 所有 远程 接口 的 方法 提供 实现 。 
java.rmi.Naming 类 用 来 存储 和 获取 在 远程 对象 注册表 里面 的 远程 对象 的 引用 。 Naming 类 的 每 一个 方法 接收 一个 URL 格式 的 String 对象 作为 它 的 参数 。 
RMI 体系 结构 分 以下 几 层 ： 存根 和 骨架 层 ( Stub   and   Skeleton   layer ) ： 这 一 层 对 程序员 是 透明 的 ， 它 主要 负责 拦截 客户端 发出 的 方法 调用 请求 ， 然后 把 请求 重 定向 给 远程 的 RMI 服务 。 远程 引用 层 ( Remote   Reference   Layer ) ： RMI 体系 结构 的 第二 层 用来 解析 客户端 对 服务端 远程 对象 的 引用 。 这 一 层 解析 并 管理 客户端 对 服务端 远程 对象 的 引用 。 连接 是 点 到 点 的 。 传输 层 ( Transport   layer ) ： 这 一 层 负责 连接 参与 服务 的 两 个 JVM 。 这 一 层 是 建立 在 网络 上 机器 间 的 TCP/IP 连接 之上 的 。 它 提供 了 基本 的 连接 服务 ， 还有 一些 防火墙 穿透 策略 。 
RMI 体系 结构 是 基于 一个 非常 重要 的 行为 定义 和 行为 实现 相 分离 的 原则 。 RMI 允许 定义 行为 的 代码 和 实现 行为 的 代码 相 分离 ， 并且 运行 在 不同 的 JVM 上 。 
Java 远程 方法 调用 ( Java   RMI ) 是 Java   API 对 远程 过程 调用 ( RPC ) 提供 的 面向 对象 的 等价 形式 ， 支持 直接 传输 序列 化 的 Java 对象 和 分布式 垃圾 回收 。 远程 方法 调用 可以 看做 是 激活 远程 正 在 运行 的 对象 上 的 方法 的 步骤 。 RMI 对 调用 者 是 位置 透明 的 ， 因为 调用 者 感觉 方法 是 执行 在 本地 运行 的 对象 上 的 。 看 下 RMI 的 一些 注意 事项 。 
像 打开 关闭 数据库 连接 这种 和 数据库 的 交互 可能 是 很 费时 的 ， 尤其 是 当 客户端 数量 增加 的 时候 ， 会 消耗 大量 的 资源 ， 成本 是 非常 高 的 。 可以 在 应用 服务器 启动 的 时候 建立 很 多 个 数据库 连接 并 维护 在 一个 池 中 。 连接 请求 由 池 中 的 连接 提供 。 在 连接 使用 完毕 以后 ， 把 连接 归还 到 池 中 ， 以 用于 满足 将来 更 多 的 请求 。 
CallableStatement 用 来 执行 存储 过程 。 存储 过程 是 由 数据库 存储 和 提供 的 。 存储 过程 可以 接受 输入 参数 ， 也 可以 有 返回 结果 。 非常 鼓励 使用 存储 过程 ， 因为 它 提供 了 安全性 和 模块 化 。 准备 一个 CallableStatement 的 方法 是 ： CallableStatement   Connection.prepareCall ( ) ; 
PreparedStatements 是 预编 译 的 ， 因此 ， 性能 会 更 好 。 同时 ， 不同 的 查询 参数 值 ， PreparedStatement 可以 重用 。 
JDBC 驱动 提供 了 特定 厂商 对 JDBC   API 接口 类 的 实现 ， 驱动 必须 要 提供 java.sql 包 下面 这些 类 的 实现 ： Connection ,   Statement ,   PreparedStatement , CallableStatement ,   ResultSet 和 Driver 。 
JDBC 是 允许 用户 在 不同 数据库 之间 做 选择 的 一个 抽象 层 。 JDBC 允许 开发 者 用 JAVA 写 数据库 应用 程序 ， 而 不 需要 关心 底层 特定 数据库 的 细节 。 
Java 中 的 Swing 组 件 使用 了 MVC （ 模型 - 视图 - 控制器 ) 设计 模式 。 
Java 使用 布局 管理 器 以 一 种 一致 的 方式 在 所有 的 窗口 平台 上 摆放 组件 。 因为 布局 管理 器 不 会 和 组件 的 绝对 大小 和 位置 相 绑定 ， 所以 他们 能够 适应 跨 窗口 系统 的 特定 平台 的 不同 。 
GUI 组 件 可以 处理 它 自己 的 事件 ， 只要 它 实现 相 对应 的 事件 监听器 接口 ， 并且 把 自己 作为 事件 监听器 。 
事件 监听器 接口 定义 了 对 特定 的 事件 ， 事件 处理器 必须 要 实现 的 方法 。 事件 适配器 给 事件 监听器 接口 提供 了 默认 的 实现 。 
当 窗口 被 AWT 重 绘 线程 进行 重 绘 的 时候 ， 它 会 把 裁剪 区域 设置 成 需要 重 绘 的 窗口 的 区域 。 
Frame 类 继承 了 Window 类 ， 它 定义 了 一个 可以 有 菜单 栏 的 主 应用 窗口 。 
GridBagLayout 里面 的 元素 是 按照 网格 进行 布局 的 。 不同 大小 的 元素 可能 会 占据 网格 的 多 于 1 行 或 一 列 。 因此 ， 行 数 和 列 数 可以 有 不同 的 大小 。 
BorderLayout 里面 的 元素 是 按照 容器 的 东西南北中 进行 布局 的 。 
CheckboxMenuItem 类 继承 自 MenuItem 类 ， 支持 菜单 选项 可以 选中 或者 不 选中 。 
限制 在 一个 给定 的 区域 或者 形状 的 绘图 操作 叫做 裁剪 。 
Canvas ,   Frame ,   Panel , 和 Applet 支持 重 绘 。 
只有 3 个 线程 安全 的 方法 ：   repaint ( ) ,   revalidate ( ) ,   and   invalidate ( ) 。 
Scrollbar 是 一个 组件 ， 不 是 容器 。 而 ScrollPane 是 容器 。 ScrollPane 自己 处理 滚动 事件 。 
布局 管理 器 用 来 在 容器 中 组织 组件 。 
Choice 是 以 一 种 紧凑 的 形式 展示 的 ， 需要 下 拉 才 能 看到 所有 的 选项 。 Choice 中 一 次 只 能 选中 一个 选项 。 List 同时 可以 有 多 个 元素 可见 ， 支持 选中 一个 或者 多 个 元素 。 
applet 安全 管理 器 是 给 applet 施加 限制 条件 的 一 种 机制 。 浏览器 可以 只 有 一个 安全 管理 器 。 安全 管理 器 在 启动 的 时候 被 创建 ， 之后 不能 被 替换 覆盖 或者 是 扩展 。 
当 applet 是 从 网络 上 加 载 的 时候 ， 它 是 由 applet 类 加 载 器 载入 的 。 类 加 载 器 有 自己 的 java 名称 空间 等级 结构 。 类 加 载 器 会 保证 来自 文件 系统 的 类 有 唯一 的 名称 空间 ， 来自 网络 资源 的 类 有 唯一 的 名称 空间 。 当 浏览器 通过 网络 载入 applet 的 时候 ， applet 的 类 被 放 置于 和 applet 的 源 相 关联 的 私有 的 名称 空间 中 。 然后 ， 那些 被 类 加 载 器 载入 进来 的 类 都 是 通过 了 验证 器 验证 的 。 验证 器 会 检查 类 文件 格式 是否 遵守 Java 语言 规范 ， 确保 不 会 出现 堆栈 溢出 ( stack   overflow ) 或者 下 溢 ( underflow ) ， 传递 给 字节 码 指令 的 参数 是 正确 的 。 
当 applet 是 从 网络 上 加 载 的 时候 ， applet 是 由 applet 类 加 载 器 载入 的 ， 它 受 applet 安全 管理 器 的 限制 。 当 applet 是 从 客户端 的 本地 磁盘 载入 的 时候 ， applet 是 由 文件 系统 加 载 器 载入 的 。 从 文件 系统 载入 的 applet 允许 在 客户端 读 文件 ， 写 文件 ， 加 载 类 库 ， 并且 也 允许 执行 其他 程序 ， 但是 ， 却 通 不 过 字节 码 校验 。 
不 受 信任 的 applet 是 不 能 访问 或是 执行 本地 系统 文件 的 Java   applet ， 默认 情况 下 ， 所有 下载 的 applet 都 是 不 受 信任 的 。 
主要 是 由于 安全 的 原因 ， 给 applet 施加 了 以下 的 限制 ： applet 不 能够 载入 类 库 或者 定义 本地 方法 。 applet 不 能 在 宿主 机上 读 写 文件 。 applet 不 能 读取 特定 的 系统 属性 。 applet 不 能 发起 网络 连接 ， 除非 是 跟 宿主 机 。 applet 不 能够 开启 宿主 机上 其他 任何 的 程序 。 
applet 是 运行 在 启用 了 java 的 浏览器 中 ， Java 应用 程序 是 可以 在 浏览器 之外 运行 的 独立 的 Java 程序 。 但是 ， 它们 都 需要 有 Java 虚拟机 。 进一步 来说 ， Java 应用 程序 需要 一个 有 特定 方法 签名 的 main 函数 来 开始 执行 。 Java   applet 不 需要 这样 的 函数 来 开始 执行 。 最后 ， Java   applet 一般 会 使用 很 严格 的 安全 策略 ， Java 应用 一般 使用 比较 宽松 的 安全 策略 。 
首先 ， 创建 applet 控制 类 的 实例 ， 然后 初始化 applet ， 最后 开始 运行 。 
applet 可以 经历 下面 的 状态 ： Init ： 每 次 被 载入 的 时候 都 会 被 初始化 。 Start ： 开始 执行 applet 。 Stop ： 结束 执行 applet 。 Destroy ： 卸 载 applet 之前 ， 做 最后 的 清理 工作 。 
java   applet 是 能够 被 包含 在 HTML 页面 中 并且 能 被 启用 了 java 的 客户端 浏览器 执行 的 程序 。 Applet 主要 用 来 创建 动态 交互 的 web 应用 程序 。 
无论 是否 抛 出 异常 ， finally 代码 块 都 会 执行 ， 它 主要 是 用来 释放 应用 占用 的 资源 。 finalize ( ) 方法 是 Object 类 的 一个 protected 方法 ， 它 是 在 对象 被 垃圾 回收 之前 由 Java 虚拟机 来 调用 的 。 
Exception 对象 会 在 下 一个 垃圾 回收 过程 中 被 回收 掉 。 
Exception 和 Error 都 是 Throwable 的 子 类 。 Exception 用于 用户 程序 可以 捕获 的 异常 情况 。 Error 定义 了 不 期望 被 用户 程序 捕获 的 异常 。 
Java 中 有 两 种 异常 ： 受 检查 的 ( checked ) 异常 和 不 受 检查 的 ( unchecked ) 异常 。 不 受 检查 的 异常 不 需要 在 方法 或者 是 构造 函数 上 声明 ， 就算 方法 或者 是 构造 函数 的 执行 可能 会 抛 出 这样 的 异常 ， 并且 不 受 检查 的 异常 可以 传播 到 方法 或者 是 构造 函数 的 外面 。 相反 ， 受 检查 的 异常 必须 要 用 throws 语句 在 方法 或者 是 构造 函数 上 声明 。 这里 有 Java 异常 处理 的 一些 小 建议 。 
垃圾 回收 不 会 发生 在 永久代 ， 如果 永久代 满 了 或者 是 超过 了 临界 值 ， 会 触发 完全 垃圾 回收 ( Full   GC ) 。 如果 你 仔细 查看 垃圾收集器 的 输出 信息 ， 就 会 发现 永久代 也 是 被 回收 的 。 这 就 是 为什么 正确 的 永久代 大小 对 避免 Full   GC 是 非常 重要 的 原因 。 请 参考 下 Java8 ： 从 永久代 到 元 数据 区 ( 注 ： Java8 中 已经 移 除了 永久代 ， 新 加 了 一个 叫做 元 数据 区 的 native 内存 区 ) 
当 对象 对 当前 使用 这个 对象 的 应用 程序 变 得 不 可 触及 的 时候 ， 这个 对象 就 可以 被 回收 了 。 
吞吐量 收集 器 使用 并行 版本 的 新生代 垃圾收集器 ， 它 用于 中等 规模 和 大规模 数据 的 应用 程序 。 而 串行 收集 器 对 大多数 的 小 应用 ( 在 现代 处理器 上 需要 大概 100M 左右 的 内存 ) 就 足够 了 。 
JVM 的 堆 是 运行 时 数据 区 ， 所有 类 的 实例 和数 组 都 是 在 堆 上 分配 内存 。 它 在 JVM 启动 的 时候 被 创建 。 对象 所 占 的 堆 内存 是 由 自动 内存 管理 系统 也 就 是 垃圾收集器 回收 。 
不 会 ， 在 下 一个 垃圾 回收 周期 中 ， 这个 对象 将 是 可 被 回收 的 。 
这 两 个 方法 用 来 提示 JVM 要 进行 垃圾 回收 。 但是 ， 立即 开始 还 是 延迟 进行 垃圾 回收 是 取决于 JVM 的 。 
Enumeration 速度 是 Iterator 的 2 倍 ， 同时 占用 更 少 的 内存 。 但是 ， Iterator 远远 比 Enumeration 安全 ， 因为 其他 线程 不 能够 修改 正在 被 iterator 遍 历 的 集合 里面 的 对象 。 同时 ， Iterator 允许 调用 者 删除 底层 集合 里面 的 元素 ， 这 对 Enumeration 来说 是 不 可能 的 。 
HashSet 是 由 一个 hash 表 来 实现 的 ， 因此 ， 它 的 元素 是 无序 的 。 add ( ) ， remove ( ) ， contains ( ) 方法 的 时间 复杂 度 是 O ( 1 ) 。 另一方面 ， TreeSet 是 由 一个 树形 的 结构 来 实现 的 ， 它 里面 的 元素 是 有序 的 。 因此 ， add ( ) ， remove ( ) ， contains ( ) 方法 的 时间 复杂 度 是 O ( logn ) 。 
根据 应用 的 需要 正确 选择 要 使用 的 集合 的 类型 对 性能 非常 重要 ， 比如 ： 假如 元素 的 数量 是 固定 的 ， 而且 能 事先 知道 ， 我们 就 应该 用 Array 而 不 是 ArrayList 。 有些 集合 类 允许 指定 初始 容量 。 因此 ， 如果 我们 能 估计 出 存储 的 元素 的 数目 ， 我们 可以 设置 初始 容量 来 避免 重新 计算 hash 值 或者 是 扩容 。 为了 类型 安全 ， 可读性 和 健壮 性 的 原因 总是 要 使用 泛 型 。 同时 ， 使用 泛 型 还 可以 避免 运行 时 的 ClassCastException 。 使用 JDK 提供 的 不 变 类 ( immutable   class ) 作为 Map 的 键 可以 避免 为 我们 自己 的 类 实现 hashCode ( ) 和 equals ( ) 方法 。 编程 的 时候 接口 优于 实现 。 底层 的 集合 实际上 是 空 的 情况 下 ， 返回 长度 是 0 的 集合 或者 是 数组 ， 不要 返回 null 。 
有序 数组 最 大 的 好处 在于 查找 的 时间 复杂 度 是 O ( log   n ) ， 而 无序 数组 是 O ( n ) 。 有序 数组 的 缺点 是 插入 操作 的 时间 复杂 度 是 O ( n ) ， 因为 值 大 的 元素 需要 往后 移动 来 给 新 元素 腾 位置 。 相反 ， 无序 数组 的 插入 时间 复杂 度 是 常量 O ( 1 ) 。 
大 O 符号 描述 了 当 数据 结构 里面 的 元素 增加 的 时候 ， 算法 的 规模 或者 是 。 大 O 符号 也 可 用 来 描述 其他 的 行为 ， 比如 ： 内存 消耗 。 因为 集合 类 实际上 是 数据 结构 ， 我们 一般 使用 大 O 符号 基于 时间 ， 内存 和 性能 来 选择 最 好 的 实现 。 大 O 符号 可以 对 大量 数据 的 性能 给 出 一个 很 好 的 说明 。 
PriorityQueue 是 一个 基于 优先级 堆 的 无 界 队列 ， 它 的 元素 是 按照 自然 顺序 ( natural   order ) 排序 的 。 在 创建 的 时候 ， 我们 可以 给 它 提供 一个 负责 给 元素 排序 的 比较 器 。 PriorityQueue 不 允许 null 值 ， 因为 他们 没有 自然 顺序 ， 或者 说 他们 没有 任何 的 相 关联 的 比较 器 。 最后 ， PriorityQueue 不 是 线程 安全 的 ， 入队 和 出 队 的 时间 复杂 度 是 O ( log ( n ) ) 。 
Java 提供 了 只 包含 一个 compareTo ( ) 方法 的 Comparable 接口 。 这个 方法 可以 个 给 两 个 对象 排序 。 具体 来说 ， 它 返回 负数 ， 0 ， 正数 来 表明 已经 存在 的 对象 小于 ， 等于 ， 大于 输入 对象 。 Java 提供 了 包含 compare ( ) 和 equals ( ) 两 个 方法 的 Comparator 接口 。 compare ( ) 方法 用 来 给 两 个 输入 参数 排序 ， 返回 负数 ， 0 ， 正数 表明 第一 个 参数 是 小于 ， 等于 ， 大于 第二 个 参数 。 equals ( ) 方法 需要 一个 对象 作为 参数 ， 它 用 来 决定 输入 参数 是否 和 comparator 相等 。 只有 当 输入 参数 也 是 一个 comparator 并且 输入 参数 和 当前 comparator 的 排序 结果 是 相同 的 时候 ， 这个 方法 才 返回 true 。 
Java 中 类 不 支持 多 继承 ， 只 支持 单 继承 （ 即 一个 类 只 有 一个 父 类 ） 。   但是 java 中 的 接口 支持 多 继承 ， ， 即 一 个子 接口 可以 有 多 个 父 接口 。 （ 接口 的 作用 是 用来 扩展 对象 的 功能 ， 一 个子 接口 继承 多 个 父 接口 ， 说 明子 接口 扩展 了 多 个 功能 ， 当 类 实现 接口 时 ， 类 就 扩展 了 相应 的 功能 ） 。 
Java 提供 和 支持 创建 抽象 类 和 接口 。 它们 的 实现 有 共同点 ， 不同 点 在于 ： 接口 中 所有 的 方法 隐含 的 都 是 抽象 的 。 而 抽象 类 则 可以 同时 包含 抽象 和 非 抽象 的 方法 。 类 可以 实现 很 多 个 接口 ， 但是 只能 继承 一个 抽象 类 类 可以 不 实现 抽象 类 和 接口 声明 的 所有 方法 ， 当然 ， 在 这种 情况 下 ， 类 也 必须 得 声明 成 是 抽象 的 。 抽象 类 可以 在 不 提供 接口 方法 实现 的 情况 下 实现 接口 。 Java 接口 中 声明 的 变量 默认 都 是 final 的 。 抽象 类 可以 包含 非 final 的 变量 。 Java 接口 中 的 成员 函数 默认 是 public 的 。 抽象 类 的 成员 函数 可以 是 private ， protected 或者 是 public 。 接口 是 绝对 抽象 的 ， 不 可以 被 实例 化 ， 抽象 类 也 不 可以 被 实例 化 。 也 可以 参考 JDK8 中 抽象 类 和 接口 的 区别 
Java 中 的 方法 重载 发生 在 同一个 类 里面 两 个 或者 是 多 个 方法 的 方法 名 相同 但是 参数 不同 的 情况 。 与 此 相对 ， 方法 覆盖 是 说 子 类 重新 定义 了 父 类 的 方法 。 方法 覆盖 必须 有 相同 的 方法 名 ， 参数 列表 和 返回 类型 。 覆盖 者 可能 不 会 限制 它 所 覆盖 的 方法 的 访问 。 
当 新 对象 被 创建 的 时候 ， 构造 方法 会 被 调 用 。 每 一个 类 都 有 构造 方法 。 在 程序员 没有 给 类 提供 构造 方法 的 情况 下 ， Java 编译器 会 为 这个 类 创建 一个 默认 的 构造 方法 。 Java 中 构造 方法 重载 和 方法 重载 很 相似 。 可以 为 一个 类 创建 多 个 构造 方法 。 每 一个 构造 方法 必须 有 它 自己 唯一 的 参数 列表 。 Java 不 支持 像 C++ 中 那样 的 复制 构造 方法 ， 这个 不同 点 是 因为 如果 你 不 自己 写 构造 方法 的 情况 下 ， Java 不 会 创建 默认 的 复制 构造 方法 。 
Java 语言 支持 的 8 种 基本 数据 类型 是 ： byteshortintlongfloatdoublebooleanchar 
“ static ” 关键字 表明 一个 成员 变量 或者 是 成员 方法 可以 在 没有 所属 的 类 的 实例 变量 的 情况 下 被 访问 。 
static 变量 在 Java 中 是 属于 类 的 ， 它 在 所有 的 实例 中 的 值 是 一样 的 。 当 类 被 Java 虚拟 机载 入 的 时候 ， 会 对 static 变量 进行 初始化 。 如果 你 的 代码 尝试 不用 实例 来 访问 非 static 的 变量 ， 编译器 会 报 错 ， 因为 这些 变量 还 没有 被 创建 出来 ， 还 没有 跟 任何 实例 关联 上 。 
死锁 是 指 两 个 或 两 个 以上 的 线程 在 执行 过程 中 ， 由于 竞争 资源 或者 由于 彼此 通信 而 造成 的 一 种 阻塞 的 现象 ， 若 无 外力 作用 ， 它们 都 将 无法 推进 下去 。 此时 称 系统 处于 死锁 状态 或 系统 产生 了 死锁 ， 这些 永远 在 互相 等待 的 进程 称为 死锁 进程 
